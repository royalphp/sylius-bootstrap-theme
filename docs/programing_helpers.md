## How to determine the theme currently in use, and which user is using it?

While coding, sometimes you require functionality that allows you to determine which theme is currently in use, or if a theme is being used at all.
Luckily, the `SyliusThemeBundle` bundle already has this functionality, but we need to properly organize it in your project.
Also, it would be handy if we could determine which part of the application is making the request,
from the admin panel side or from the customer's shop side (for example, you'll need this while using the `SyliusGridBundle` bundle).

Let's create a helper that will use the theme context,

> [!NOTE]  
> We are using the `App\Utils` namespace for universality, but feel free to use any other you like.

For example, first let's create an interface:

```php
<?php

namespace App\Utils;

interface UserThemeHelperInterface
{
    public function isBootstrapTheme(): bool;
}
```

and then we implement this interface:

```php
<?php

namespace App\Utils;

use Sylius\Bundle\ThemeBundle\Context\ThemeContextInterface;

final readonly class UserThemeHelper implements UserThemeHelperInterface
{
    public function __construct(
        private ThemeContextInterface $themeContext,
    ) {
    }

    public function isBootstrapTheme(string $keyword = 'bootstrap'): bool
    {
        return str_contains($this->themeContext->getTheme()?->getName() ?? '', $keyword);
    }
}
```

> [!IMPORTANT]  
> We use the common keyword `bootstrap` because this theme is called `royalphp/sylius-bootstrap-theme` according to the `composer.json`.
> This means that if your theme carries a different common name, you should specify it to correctly identify it.

By implementing the `isBootstrapTheme` method, we can determine the theme in use by keyword.

Now, let's create functionality using which you could determine which part of the site you are in.

For example, first, let's create an interface:

```php
<?php

namespace App\Utils;

interface UserAccessHelperInterface
{
    final public const string SIDE_BACK = 'admin';
    final public const string SIDE_FRONT = 'shop';

    public function isAdminUser(): bool;

    public function isShopUser(): bool;

    public function isAdminPage(): bool;

    public function isShopPage(): bool;
}
```

and then we implement this interface:

```php
<?php

namespace App\Utils;

use Sylius\Component\Core\Model\AdminUserInterface;
use Sylius\Component\Core\Model\ShopUserInterface;
use Sylius\Component\User\Model\UserInterface;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
use Symfony\Component\Security\Core\Authentication\Token\UsernamePasswordToken;
use Symfony\Component\Security\Core\Exception\AccessDeniedException;

final readonly class UserAccessHelper implements UserAccessHelperInterface
{
    public function __construct(
        private TokenStorageInterface $tokenStorage,
    ) {
    }

    public function isAdminUser(): bool
    {
        return $this->getCurrentUser() instanceof AdminUserInterface;
    }

    public function isShopUser(): bool
    {
        return $this->getCurrentUser() instanceof ShopUserInterface;
    }

    public function isAdminPage(): bool
    {
        return $this->isSidePage(self::SIDE_BACK);
    }

    public function isShopPage(): bool
    {
        return $this->isSidePage(self::SIDE_FRONT);
    }

    private function getCurrentUser(): UserInterface
    {
        $user = $this->tokenStorage->getToken()?->getUser();

        if (!($user instanceof UserInterface)) {
            throw new AccessDeniedException();
        }

        return $user;
    }

    private function isSidePage(string $side): bool
    {
        $token = $this->tokenStorage->getToken();

        if (!($token instanceof UsernamePasswordToken)) {
            throw new AccessDeniedException();
        }

        return $side === $token->getFirewallName();
    }
}
```

Here we're determining the current page based on the user, meaning that we use the built-in security bundle's firewall to ensure that your class has access to the specified service.

Now it is a good time to put your helpers to good use, and let's propose such an example.
At present, if you turn on the `SyliusBootstrapTheme` and go to the customer account page of the shop, and look at the sidebar of his additional details,
you may note that not all the menu items have icons displayed, specifically for `Dashboard`, and `Personal information` items. Let's fix that.

> [!NOTE]  
> Actually, we didn't forget to put icons. It was left unchanged on purpose for this example's sake.
> The fact is, that this menu gets built by events and there's no way in the templates to change these specific menu items,
> because they get generated by internal components, however, if you don't wish to use this approach,
> you can hardcode these menu items in the necessary template, and this would override the default output of these items.

In Sylius project, menus are built using `KnpMenuBundle`, therefore, if you wish to delve deeper into this issue,
you can read [this guide](https://symfony.com/bundles/KnpMenuBundle/current/index.html),
or read [customization guide](https://docs.sylius.com/en/latest/customization/menu.html) from Sylius' devs team.
Though, you can follow the next steps if you just wish to get the result without going into details.

Firstly, let's create a listener for a customer's shop account menu, for this create the following `App\Menu\ShopAccountMenuListener` class:

```php
<?php

namespace App\Menu;

use Sylius\Bundle\UiBundle\Menu\Event\MenuBuilderEvent;
use Symfony\Component\EventDispatcher\Attribute\AsEventListener;

#[AsEventListener(event: 'sylius.menu.shop.account', method: 'onSyliusMenuShopAccount')]
final readonly class ShopAccountMenuListener
{
    public function onSyliusMenuShopAccount(MenuBuilderEvent $event): void
    {
        // ...
    }
}
```

> [!NOTE]  
> We configure the service through attributes, but this can still be configured through the `config/services.yaml` file.

Now you have a listener class using which you can change a customer's shop account menu,
let's do it right now using our helpers by writing a condition under which we will display the icons:

```php
<?php

namespace App\Menu;

use App\Utils\UserThemeHelperInterface;
use Sylius\Bundle\UiBundle\Menu\Event\MenuBuilderEvent;
use Symfony\Component\EventDispatcher\Attribute\AsEventListener;

#[AsEventListener(event: 'sylius.menu.shop.account', method: 'onSyliusMenuShopAccount')]
final readonly class ShopAccountMenuListener
{
    public function __construct(
        private UserThemeHelperInterface $userThemeHelper,
    ) {
    }

    public function onSyliusMenuShopAccount(MenuBuilderEvent $event): void
    {
        $menu = $event->getMenu();

        if ($this->userThemeHelper->isBootstrapTheme()) {
            $menu->getChild('dashboard')?->setLabelAttribute('icon', 'house');
            $menu->getChild('personal_information')?->setLabelAttribute('icon', 'person');
        }
    }
}
```

Now, if you refresh the customer shop account page, all the icons for each menu item will be filled out,
also you can try disabling the theme and make sure that the old design still works and shows correct icons.
Thus you can programmatically control the behavior of your theme, in this example the usage of theme helper was shown,
however, in this guide you can see how else you can use the user access helper.

**[Go back to the documentation's programing](programing.md)**
